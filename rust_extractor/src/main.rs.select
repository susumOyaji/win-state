use serde_json::Value;
use regex::Regex;
use std::error::Error;

#[derive(Debug)]
struct Candidate<'a> {
    kind: &'static str,
    path: String,
    value: &'a Value,
    score: f32,
}

fn walk_json<'a>(v: &'a Value, path: String, results: &mut Vec<Candidate<'a>>) {
    match v {
        Value::Object(map) => {
            for (k, val) in map {
                let new_path = if path.is_empty() {
                    k.clone()
                } else {
                    format!("{}/{}", path, k)
                };
                walk_json(val, new_path, results);
            }
        }
        Value::Array(arr) => {
            for (i, val) in arr.iter().enumerate() {
                walk_json(val, format!("{}/[{}]", path, i), results);
            }
        }
        _ => classify_and_score(path, v, results),
    }
}

fn classify_and_score<'a>(path: String, value: &'a Value, results: &mut Vec<Candidate<'a>>) {
    let s = match value {
        Value::String(s) => s.trim().to_string(),
        Value::Number(n) => n.to_string(),
        _ => return,
    };

    // ğŸ”¸ é™¤å¤–ãƒ¯ãƒ¼ãƒ‰ï¼ˆéå»ãƒ‡ãƒ¼ã‚¿ãªã©ï¼‰
    let excluded = ["lowPrice", "highPrice", "previousClose"];
    if excluded.iter().any(|&w| path.contains(w)) {
        return;
    }

    // ğŸ”¸ æ­£è¦è¡¨ç¾
    let re_unsigned = Regex::new(r"^\d+(\.\d+)?$").unwrap();     // ç¬¦å·ãªã—æ•°å€¤
    let re_signed = Regex::new(r"^[+-]\d+(\.\d+)?$").unwrap();   // ç¬¦å·ä»˜ãæ•°å€¤
    let re_percent = Regex::new(r"^[+-]?\d+(\.\d+)?%$").unwrap(); // ï¼…ä»˜ã
    let re_time = Regex::new(r"^\d{2}:\d{2}$").unwrap();         // hh:mmå½¢å¼

    let mut score = 0.0;

    // ğŸ”¹ æ§‹é€ ã‚¹ã‚³ã‚¢è£œæ­£
    if path.contains("priceBoard") || path.contains("mainStocks") {
        score += 0.5;
    }

    // ğŸ”¹ å€¤ã®åˆ†é¡ã¨ã‚¹ã‚³ã‚¢
    if re_percent.is_match(&s) {
        let kind = "Change%";
        if path.contains("priceChangeRate") {
            score += 0.5; // èªå½™è£œæ­£
        }
        results.push(Candidate { kind, path, value, score });
    } else if re_signed.is_match(&s) {
        results.push(Candidate { kind: "Change", path, value, score });
    } else if re_unsigned.is_match(&s) {
        results.push(Candidate { kind: "Price", path, value, score });
    } else if re_time.is_match(&s) {
        results.push(Candidate { kind: "Time", path, value, score });
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let url = "https://finance.yahoo.co.jp/quote/5016.T";
    let body = reqwest::get(url).await?.text().await?;

    let re = Regex::new(r"(?s)window\.__PRELOADED_STATE__\s*=\s*(.*?)</script>")?;
    if let Some(caps) = re.captures(&body) {
        if let Some(json_str_match) = caps.get(1) {
            let mut json_str = json_str_match.as_str().trim();
            if json_str.ends_with(';') {
                json_str = &json_str[..json_str.len() - 1];
            }

            let data: Value = serde_json::from_str(json_str)?;
            let mut results = vec![];
            walk_json(&data, "".into(), &mut results);

            // ğŸ”¸ ç¨®åˆ¥ã”ã¨ã«æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’æŠ½å‡º
            let get_best = |kind: &str| {
                results.iter()
                    .filter(|c| c.kind == kind)
                    .max_by(|a, b| a.score.partial_cmp(&b.score).unwrap())
                    .map(|c| (c.path.clone(), c.value.clone()))
            };

            let price = get_best("Price");
            let change = get_best("Change");
            let change_percent = get_best("Change%");
            let time = get_best("Time");

            println!("==============================");
            println!("ğŸ’´ Price: {:?}", price);
            println!("ğŸ“‰ Change: {:?}", change);
            println!("ğŸ“Š Change%: {:?}", change_percent);
            println!("ğŸ•’ Time: {:?}", time);
            println!("==============================");
        }
    }

    Ok(())
}
